//! Data types representing HEOS groups.
//!
//! A HEOS group comprises two or more [players](player), with one player being designated as the
//! "group leader". Controlling a group is done via controlling the group leader, and all other
//! players in the group will synchronize with said leader.

use serde::{Deserialize, Serialize};
use std::str::FromStr;
use strum::EnumString;

use super::*;
use crate::data::player::PlayerId;

id_type! {
    /// ID representing a HEOS group.
    ///
    /// This ID can be any number, and is generated by the HEOS system, making it effectively
    /// opaque.
    pub struct GroupId(pub i64);
}

/// The roles a player can have while participating in a group.
#[derive(Serialize, Deserialize, EnumString, strum::Display, Debug, Clone, Copy, PartialEq, Eq)]
#[serde(into = "String", try_from = "String")]
#[strum(serialize_all = "lowercase")]
pub enum GroupRole {
    /// This player is the group leader.
    ///
    /// Only one player may be the group leader.
    Leader,
    /// This player is a group member.
    ///
    /// All players except for the leader are members.
    Member,
}
impl_enum_string_conversions!(GroupRole);

/// Information about a player that is participating in a group.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GroupPlayer {
    /// The user-friendly name of the player.
    pub name: String,
    /// ID of the player.
    #[serde(rename = "pid")]
    pub player_id: PlayerId,
    /// The role the player has in the group.
    pub role: GroupRole,
}

/// Information about a specific group.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GroupInfo {
    /// The user-friendly name of the group.
    pub name: String,
    /// ID of the group.
    #[serde(rename = "gid")]
    pub group_id: GroupId,
    /// List of all players in the group.
    pub players: Vec<GroupPlayer>,
}
impl_try_from_response_payload!(GroupInfo);
impl_try_from_response_payload!(Vec<GroupInfo>);

impl GroupInfo {
    /// Get the group's leader.
    ///
    /// # Panics
    ///
    /// Panics if no group member is designated as the leader, which should _not_ occur.
    pub fn leader(&self) -> &GroupPlayer {
        for player in &self.players {
            if player.role == GroupRole::Leader {
                return player
            }
        }
        panic!("every group should have a leader")
    }

    /// Retrieve a player from the group by ID.
    ///
    /// If no player exists in the group with the specified ID, yields `None`.
    pub fn player(&self, player_id: PlayerId) -> Option<&GroupPlayer> {
        for player in &self.players {
            if player.player_id == player_id {
                return Some(player)
            }
        }
        None
    }
}